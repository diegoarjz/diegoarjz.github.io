<!doctype html><html dir=ltr lang=en data-theme><head>
<title>
Diego Jesus
|
Creating a Simple Building
</title>
<meta charset=utf-8><meta name=generator content="Hugo 0.88.1"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name=description content="
      Procedural Recipes


    ">
<link rel=stylesheet href=/css/main.min.62c68e6209f6e0ad6a21a6c89488202f1ac09c13fc07856ebd509ecd54ab3196.css integrity="sha256-YsaOYgn24K1qIabIlIggLxrAnBP8B4VuvVCezVSrMZY=" crossorigin=anonymous type=text/css>
<link rel=stylesheet href=/css/markupHighlight.min.8e4c8f0a940b1596fb4c64d28a00a5ceed671fc303cb65178b4947417da9c674.css integrity="sha256-jkyPCpQLFZb7TGTSigClzu1nH8MDy2UXi0lHQX2pxnQ=" crossorigin=anonymous type=text/css>
<link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css integrity="sha512-+4zCK9k+qNFUR5X+cKL9EIR+ZOhtIloNl9GIKS57V1MyNsYpYcUrUeQc9vNfzsWfV28IaLL3i96P9sdNyeRssA==" crossorigin=anonymous>
<link rel="shortcut icon" href=/favicon.ico type=image/x-icon>
<link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png>
<link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png>
<link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png>
<link rel=canonical href=/posts/creating-a-simple-building/>
<script type=text/javascript src=/js/anatole-header.min.2a2cd9614b7d007dfbb75e8da19e3a0fa872ceab53c6d000c00b7a0c89b85bfc.js integrity="sha256-KizZYUt9AH37t16NoZ46D6hyzqtTxtAAwAt6DIm4W/w=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/anatole-theme-switcher.min.7fd87181cdd7e8413aa64b6867bb32f3a8dc242e684fc7d5bbb9f600dbc2b6eb.js integrity="sha256-f9hxgc3X6EE6pktoZ7sy86jcJC5oT8fVu7n2ANvCtus=" crossorigin=anonymous></script>
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Creating a Simple Building">
<meta name=twitter:description content="I decided to start my series of posts with an example of how we can create a simple building using pagoda. Hopefully this will help understand how pagoda can be used to generate 3D content.
Pagoda has a graph based approach to defining the rules with which we can generate our models. This means that nodes in this graph create, modify or otherwise perform any sort of operation on our objects and edges define the flow of objects between nodes.">
<script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","articleSection":"posts","name":"Creating a Simple Building","headline":"Creating a Simple Building","alternativeHeadline":"","description":"
      
        I decided to start my series of posts with an example of how we can create a simple building using pagoda. Hopefully this will help understand how pagoda can be used to generate 3D content.\nPagoda has a graph based approach to defining the rules with which we can generate our models. This means that nodes in this graph create, modify or otherwise perform any sort of operation on our objects and edges define the flow of objects between nodes.


      


    ","inLanguage":"en-us","isFamilyFriendly":"true","mainEntityOfPage":{"@type":"WebPage","@id":"http:\/\/diegoarjz.github.io\/posts\/creating-a-simple-building\/"},"author":{"@type":"Person","name":"Diego Jesus"},"creator":{"@type":"Person","name":"Diego Jesus"},"accountablePerson":{"@type":"Person","name":"Diego Jesus"},"copyrightHolder":{"@type":"Person","name":"Diego Jesus"},"copyrightYear":"2021","dateCreated":"2021-09-07T18:16:19.00Z","datePublished":"2021-09-07T18:16:19.00Z","dateModified":"2021-09-07T18:16:19.00Z","publisher":{"@type":"Organization","name":"Diego Jesus","url":"http://diegoarjz.github.io/","logo":{"@type":"ImageObject","url":"http:\/\/diegoarjz.github.io\/favicon-32x32.png","width":"32","height":"32"}},"image":[],"url":"http:\/\/diegoarjz.github.io\/posts\/creating-a-simple-building\/","wordCount":"1717","genre":[],"keywords":[]}</script>
</head>
<body>
<header><div class="page-top
animated fadeInDown">
<a role=button class=navbar-burger data-target=navMenu aria-label=menu aria-expanded=false>
<span aria-hidden=true></span>
<span aria-hidden=true></span>
<span aria-hidden=true></span>
</a>
<nav>
<ul class=nav__list id=navMenu>
<div class=nav__links>
<li>
<a href=/ title>Home</a>
</li>
<li>
<a href=/about/ title>About</a>
</li>
<li>
<a href=/cv/ title>CV</a>
</li>
</div>
<li>
<a class=theme-switch title="Switch Theme">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i>
</a>
</li>
</ul>
</nav>
</div>
</header>
<div class=wrapper>
<aside><div class="sidebar
animated fadeInDown">
<div class=sidebar__content>
<div class=logo-title>
<div class=title>
<img src=/images/ProfilePic.jpg alt="profile picture">
<h3 title><a href=/>Procedural Recipes</a></h3>
<div class=description>
<p>Procedural Recipes</p>
</div>
</div>
</div>
<ul class=social-links>
<li>
<a href=https://www.linkedin.com/in/djesus/ rel=me aria-label=Linkedin>
<i class="fab fa-linkedin fa-2x" aria-hidden=true></i>
</a>
</li>
<li>
<a href=https://github.com/diegoarjz rel=me aria-label=GitHub>
<i class="fab fa-github fa-2x" aria-hidden=true></i>
</a>
</li>
<li>
<a href=https://twitter.com/diegoarjz rel=me aria-label=Twitter>
<i class="fab fa-twitter fa-2x" aria-hidden=true></i>
</a>
</li>
<li>
<a href=mailto:diego.a.r.jz@gmail.com rel=me aria-label=e-mail>
<i class="fas fa-envelope fa-2x" aria-hidden=true></i>
</a>
</li>
</ul>
</div><footer class="footer footer--sidebar">
<div class=by_farbox>
<ul class=footer__list>
<li class=footer__item>
&copy;
Diego Jesus
2021
</li>
</ul>
</div>
</footer>
<script type=text/javascript src=/js/medium-zoom.min.71100d84fab0ad794b8399a66ac810700cc78d703f715dc10af4d7ba7b761362.js integrity="sha256-cRANhPqwrXlLg5mmasgQcAzHjXA/cV3BCvTXunt2E2I=" crossorigin=anonymous></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-65082977-3','auto'),ga('send','pageview'))</script>
<script async src=https://www.google-analytics.com/analytics.js></script>
</div>
</aside>
<main>
<div class=autopagerize_page_element>
<div class=content>
<div class="post
animated fadeInDown">
<div class=post-content>
<div class=post-title>
<h1>Creating a Simple Building</h1>
</div><p>I decided to start my series of posts with an example of how we can create
a simple building using <a href=https://github.com/diegoarjz/pagoda>pagoda</a>.
Hopefully this will help understand how pagoda can be used to generate 3D
content.</p>
<p>Pagoda has a graph based approach to defining the rules with which we can generate our models. This means that nodes in this graph create, modify or otherwise perform any sort of operation on our objects and edges define the flow of objects between nodes.</p>
<p>As a heads up, pagoda does not yet have a GUI editor that would allow us to
visually create the rules to generate our models. Hopefully, I will be able to
get that going in the next release. For now, we can use the graph specification
language that pagoda provides.</p>
<p>So let&rsquo;s get started with our building which, in the end, will look something like the following image.</p>
<p><img src=/images/posts/creating-a-simple-building/final.png alt="Simple Building Final"></p>
<p>The first step is to create a graph file and edit it with your favourite text editor. I creatively named this file <code>simple_building.pgd</code> and added the following:</p>
<pre tabindex=0><code>building_volume = Operation(operation: &quot;CreateBoxGeometry&quot;) {
    xSize: 30, ySize: 10, zSize: 20
}
building_volume_out = OutputInterface(interface: &quot;out&quot;)

building_volume -&gt; building_volume_out;
</code></pre><p>First, we define the building volume by creating a box with <code>(30, 10, 20)</code>
units along the <code>x</code>, <code>y</code>, and <code>z</code> directions respectively. To do this, we need
to create an <code>Operation</code> node with the <code>CreateBoxGeometry</code> operation. Objects
created with this operation are placed in the operation&rsquo;s <code>out</code> interface and,
therefore, we need an <code>OutputInterface</code> node to extract them and route them
downstream. By pagoda&rsquo;s convention, the <code>z</code> direction points upwards when we
are creating a new object. This means that our building will be 20 units tall.</p>
<p>If you now execute the graph you will see something similar to the following:</p>
<pre tabindex=0><code>$ pagoda simple_building.pgd --execute
Info: Executing node 'building_volume'
Info: Executing node 'building_volume_out'
</code></pre><p>This will tell you which nodes are executing and in which order. It tells you that both nodes were executed, but where did the box end up? The answer is &lsquo;nowhere&rsquo;. The box geometry was, indeed, created but it was then disposed of.</p>
<p>Since pagoda&rsquo;s philosophy is to have everything controlled by nodes and that each node or operation must have a very precise use, we need to explicitly tell it to do something with the geometry. To exemplify, we will export the geometry to an <code>obj</code> file by creating an <code>ExportGeometry</code> operation. We can do that with by adding the following snippet.</p>
<pre tabindex=0><code>export_geometry_in = InputInterface(interface: &quot;in&quot;)
export_geometry = Operation(operation: &quot;ExportGeometry&quot;) {
    path: $&lt; &quot;out/geometry&quot; + op.count + &quot;.obj&quot;; &gt;$
}
export_geometry_in -&gt; export_geometry;
</code></pre><p>The <code>ExportGeometry</code> operation exports all of the geometries that come in through its <code>in</code> input interface and writes it to the <code>obj</code> file specified in its <code>path</code> parameter. As such, we need to create an <code>InputInterface</code> node to route the objects to that interface.</p>
<p>The path parameter in the above snippet is a bit weird. This is because it is, in fact, using <code>pgscript</code> to specify the final path. Although not very important in this case, we needed a way to separate the various incoming objects into different files. That is why we are computing the final path based on the <code>op.count</code> exposed parameter.</p>
<p>All that is left to do is to connect the <code>out</code> output interface of the <code>CreateBoxGeometry</code> operation to the <code>in</code> input interface of the <code>ExportGeometry</code> operation. This is done like this:</p>
<pre tabindex=0><code>building_volume_out -&gt; export_geometry_in;
</code></pre><p>If you now run the graph, you can see the following output and a <code>geometry0.obj</code>inside the <code>out</code> folder. If that folder doesn&rsquo;t exist, pagoda creates it automatically.</p>
<pre tabindex=0><code>$ pagoda simple_building.pgd --execute
Info: Executing node 'building_volume'
Info: Executing node 'building_volume_out'
Info: Executing node 'export_geometry_in'
Info: Executing node 'export_geometry'
</code></pre><p>As we move along, you can reuse the export geometry node we created to see how the geometry looks like at any point, by connecting output interface nodes to the <code>export_geometry_in</code> node. Because, in the end, we won&rsquo;t be using the geometry created by the <code>building_volume</code> node, you can delete disconnect the two nodes by deleting the line we added two snippets above.</p>
<p>The next step is to add a little bit of detail to the faces of the building volume but first we need to separate each face into its own object. The <code>ExtractFaces</code> operation does exactly this: for face of each object in its <code>in</code> interface creates an object in its <code>out</code> interface.</p>
<p>The question now becomes: <em>How can we distinguish the façades from the roof?</em></p>
<p>This can be done with the <code>Router</code> node. This nodes evaluates predicates on the input objects and routes them to specific downstream nodes.</p>
<p>So let&rsquo;s see how we can do this. First the bit with the <code>ExtractFaces</code> operation:</p>
<pre tabindex=0><code>building_faces_in = InputInterface(interface: &quot;in&quot;)
building_faces = Operation(operation: &quot;ExtractFaces&quot;)
building_faces_out = OutputInterface(interface: &quot;out&quot;)
building_faces_in -&gt; building_faces -&gt; building_faces_out;

building_volume_out -&gt; building_faces_in;
</code></pre><p>And now the <code>Router</code> node:</p>
<pre tabindex=0><code>building_face_router = Router() {
    facade_in: &quot;side&quot;,
    roof_in: &quot;up&quot;
}

building_faces_out -&gt; building_face_router;
</code></pre><p>In the snippet above, the execution parameter names (facade and roof) correspond to downstream nodes (we&rsquo;ll get to that next) and the &ldquo;side&rdquo; and &ldquo;up&rdquo; are predicate names that pagoda provides. In this case, the node is routing the side faces to the <code>facade_in</code> downstream node and the up face to the <code>roof_in</code> downstream node.</p>
<p>Let&rsquo;s get to adding some detail to the roof. We will introduce the <code>FaceOffset</code> operation which takes faces in the incoming objects and creates offset faces at a given distance from the original face&rsquo;s edge.</p>
<pre tabindex=0><code>roof_in = InputInterface(interface: &quot;in&quot;)
roof = Operation(operation: &quot;FaceOffset&quot;) {
    amount: 4
}
roof_inner = OutputInterface(interface: &quot;inner&quot;)
roof_outer = OutputInterface(interface: &quot;outer&quot;)
roof_in -&gt; roof -&gt; roof_inner;
roof -&gt; roof_outer;

building_face_router -&gt; roof_in;
</code></pre><p>The <code>FaceOffset</code> operation has two output interfaces allowing to distinguish
between interior and border objects. As you can see in the snippet above, these
interfaces are named <em>inner</em> and <em>outer</em> respectively.</p>
<p>We will achieve the last detail in the roof by extruding the inner face
generated by the above operation. Conveniently, there is an <code>ExtrudeGeometry</code>
operation. Let&rsquo;s add it to the graph file.</p>
<pre tabindex=0><code>roof_extrusion_in = InputInterface(interface: &quot;in&quot;)
roof_extrusion = Operation(operation: &quot;ExtrudeGeometry&quot;) {
    extrusion_amount: 1
}
roof_extrusion_out = OutputInterface(interface: &quot;out&quot;)
roof_extrusion_in -&gt; roof_extrusion -&gt; roof_extrusion_out;

roof_inner -&gt; roof_extrusion_in;
</code></pre><p>Next, we can divide the façades into floors and then into windows. This can be
done with two chained <code>RepeatSplit</code> operations, alternating its axis. First, we
split along the <em>y</em> axis and then the <em>x</em> axis. This will give us a grid like
structure in the façade.</p>
<p>Remember earlier in this post when I mentioned that the <em>z</em> direction pointed
upwards? So why are we splitting the façades along the <em>y</em> direction first? The
reason is that every object that is created in pagoda has a <em>scope</em> which is,
basically, an oriented bounding box. Implicitly, this defines a frame of
coordinates for each object and in the case of our façades, the <em>x</em> axis moves
left to right along the bottom edge, the <em>y</em> axis moves bottom to top along the
left edge. Consequentially, the <em>z</em> axis points outwards.</p>
<pre tabindex=0><code>facade_in = InputInterface(interface: &quot;in&quot;)
facade = Operation(operation: &quot;RepeatSplit&quot;) {
    axis: &quot;y&quot;,
    size: 1.5,
    adjust: &quot;true&quot;
}
facade_out = OutputInterface(interface: &quot;out&quot;)
facade_in -&gt; facade -&gt; facade_out;
building_face_router -&gt; facade_in;

floor_in = InputInterface(interface: &quot;in&quot;)
floor = Operation(operation: &quot;RepeatSplit&quot;) {
    axis: &quot;x&quot;,
    size: 1,
    adjust: &quot;true&quot;
}
floor_out = OutputInterface(interface: &quot;out&quot;)
floor_in -&gt; floor -&gt; floor_out;

facade_out -&gt; floor_in;
</code></pre><p>The final bit is to export the geometries we&rsquo;re interested in. We can use the <code>ExportGeometry</code> operation we defined above to which we connect the <code>floor_out</code> <code>roof_extrusion_out</code> and <code>roof_outer</code> nodes as follows.</p>
<pre tabindex=0><code>floor_out -&gt; export_geometry_in;
roof_extrusion_out -&gt; export_geometry_in;
roof_outer -&gt; export_geometry_in;
</code></pre><p>Your <code>simple_building.pgd</code> file should now look something like this:</p>
<pre tabindex=0><code>building_volume = Operation(operation: &quot;CreateBoxGeometry&quot;) {
    xSize: 30, ySize: 10, zSize: 20
}
building_volume_out = OutputInterface(interface: &quot;out&quot;)
building_volume -&gt; building_volume_out;

export_geometry_in = InputInterface(interface: &quot;in&quot;)
export_geometry = Operation(operation: &quot;ExportGeometry&quot;) {
    path: $&lt; &quot;out/geometry&quot; + op.count + &quot;.obj&quot;; &gt;$
}
export_geometry_in -&gt; export_geometry;

building_faces_in = InputInterface(interface: &quot;in&quot;)
building_faces = Operation(operation: &quot;ExtractFaces&quot;)
building_faces_out = OutputInterface(interface: &quot;out&quot;)
building_faces_in -&gt; building_faces -&gt; building_faces_out;

building_volume_out -&gt; building_faces_in;

building_face_router = Router() {
    facade_in: &quot;side&quot;,
    roof_in: &quot;up&quot;
}
building_faces_out -&gt; building_face_router;

roof_in = InputInterface(interface: &quot;in&quot;)
roof = Operation(operation: &quot;FaceOffset&quot;) {
    amount: 4
}
roof_inner = OutputInterface(interface: &quot;inner&quot;)
roof_outer = OutputInterface(interface: &quot;outer&quot;)
roof_in -&gt; roof -&gt; roof_inner;
roof -&gt; roof_outer;

building_face_router -&gt; roof_in;

roof_extrusion_in = InputInterface(interface: &quot;in&quot;)
roof_extrusion = Operation(operation: &quot;ExtrudeGeometry&quot;) {
    extrusion_amount: 1
}
roof_extrusion_out = OutputInterface(interface: &quot;out&quot;)
roof_extrusion_in -&gt; roof_extrusion -&gt; roof_extrusion_out;

roof_inner -&gt; roof_extrusion_in;

facade_in = InputInterface(interface: &quot;in&quot;)
facade = Operation(operation: &quot;RepeatSplit&quot;) {
    axis: &quot;y&quot;,
    size: 1.5,
    adjust: &quot;true&quot;
}
facade_out = OutputInterface(interface: &quot;out&quot;)
facade_in -&gt; facade -&gt; facade_out;
building_face_router -&gt; facade_in;

floor_in = InputInterface(interface: &quot;in&quot;)
floor = Operation(operation: &quot;RepeatSplit&quot;) {
    axis: &quot;x&quot;,
    size: 1,
    adjust: &quot;true&quot;
}
floor_out = OutputInterface(interface: &quot;out&quot;)
floor_in -&gt; floor -&gt; floor_out;

facade_out -&gt; floor_in;

floor_out -&gt; export_geometry_in;
roof_extrusion_out -&gt; export_geometry_in;
roof_outer -&gt; export_geometry_in;
</code></pre><p>You can now run the graph file to generate the whole building. You will see the as each node is executed and, in the end, all files generated by pagoda will be output to the <code>out</code> directory.</p>
<pre tabindex=0><code>$ pagoda final.pgd --execute
Info: Executing node 'building_volume'
Info: Executing node 'building_volume_out'
Info: Executing node 'building_faces_in'
Info: Executing node 'building_faces'
Info: Executing node 'building_faces_out'
Info: Executing node 'building_face_router'
Info: Executing node 'roof_in'
Info: Executing node 'facade_in'
Info: Executing node 'roof'
Info: Executing node 'facade'
Info: Executing node 'roof_inner'
Info: Executing node 'roof_outer'
Info: Executing node 'facade_out'
Info: Executing node 'roof_extrusion_in'
Info: Executing node 'floor_in'
Info: Executing node 'roof_extrusion'
Info: Executing node 'floor'
Info: Executing node 'roof_extrusion_out'
Info: Executing node 'floor_out'
Info: Executing node 'export_geometry_in'
Info: Executing node 'export_geometry'
</code></pre><p>You&rsquo;re probably wondering why there are so many <code>obj</code> files in the <code>out</code> directory. The reason is that, currently, pagoda creates a new geometry for each object that it creates. In the future, we might see some reuse of geometries between different objects and, instead of ending up with hundreds of files, we might get a single geometry file with the entire building.</p>
<p>For the time being, however, we&rsquo;re stuck with importing all these files to (for example) blender to get a nice render like the one at the top of the post.</p>
<p>I hope you enjoyed reading this post and, if you have any question, suggestion or otherwise just want to get in touch, feel free to send me an email or reach out via Twitter.</p>
</div>
<div class=post-footer>
<div class=info>
</div>
</div>
</div>
</div>
</div>
</main>
</div><footer class="footer footer--base">
<div class=by_farbox>
<ul class=footer__list>
<li class=footer__item>
&copy;
Diego Jesus
2021
</li>
</ul>
</div>
</footer>
<script type=text/javascript src=/js/medium-zoom.min.71100d84fab0ad794b8399a66ac810700cc78d703f715dc10af4d7ba7b761362.js integrity="sha256-cRANhPqwrXlLg5mmasgQcAzHjXA/cV3BCvTXunt2E2I=" crossorigin=anonymous></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-65082977-3','auto'),ga('send','pageview'))</script>
<script async src=https://www.google-analytics.com/analytics.js></script>
</body>
</html>